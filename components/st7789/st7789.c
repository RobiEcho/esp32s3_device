#include "st7789.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "ST7789";
static spi_device_handle_t hspi = NULL; // spi设备句柄

/* 内部函数声明 */
static void send_cmd(uint8_t cmd);
static void send_data(const uint8_t *data, size_t len);
static void hardware_reset(void);
static void set_address_window(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1);

void st7789_init(void) {
    // GPIO初始化（DC/RES引脚）
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << ST7789_DC_PIN) | (1ULL << ST7789_RES_PIN),  // 配置DC和RES两个引脚
        .mode = GPIO_MODE_OUTPUT,          // 设置为输出模式
        .intr_type = GPIO_INTR_DISABLE,    // 禁用GPIO中断
        .pull_up_en = GPIO_PULLUP_DISABLE, // 禁用内部上拉电阻
        .pull_down_en = GPIO_PULLDOWN_DISABLE  // 禁用内部下拉电阻
    };
    ESP_ERROR_CHECK(gpio_config(&io_conf));

    // SPI总线配置
    spi_bus_config_t buscfg = {
        .mosi_io_num = ST7789_MOSI_PIN,           // 主机输出从机输入引脚（数据线）
        .miso_io_num = -1,                        // 不使用MISO（显示屏只接收数据）
        .sclk_io_num = ST7789_SCLK_PIN,           // SPI时钟引脚
        .quadwp_io_num = -1,                      // 不使用四线SPI的WP引脚
        .quadhd_io_num = -1,                      // 不使用四线SPI的HD引脚
        .max_transfer_sz = ST7789_MAX_TRANS_SIZE * 2  // 最大传输字节数（每个像素2字节）
    };

    // SPI设备配置
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 40 * 1000 * 1000,   // SPI时钟频率40MHz
        .mode = 3,                            // SPI模式3（CPOL=1, CPHA=1）
        .spics_io_num = -1,                   // 不使用CS引脚
        .queue_size = 7,                      // SPI事务队列大小
        .flags = SPI_DEVICE_HALFDUPLEX | SPI_DEVICE_NO_DUMMY  // 半双工模式，无dummy位
    };

    // 初始化SPI总线及设备
    ESP_ERROR_CHECK(spi_bus_initialize(ST7789_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));// 初始化SPI总线
    ESP_ERROR_CHECK(spi_bus_add_device(ST7789_SPI_HOST, &devcfg, &hspi));// 初始化SPI设备

    hardware_reset();   // 硬件复位序列

    send_cmd(ST7789_CMD_SLEEP_OUT); // 退出睡眠模式
    vTaskDelay(pdMS_TO_TICKS(120));

    send_cmd(ST7789_CMD_INVON);  // 开启硬件颜色反转

    send_cmd(ST7789_CMD_COLMOD); // 设置颜色模式
    uint8_t mode = ST7789_PIXEL_FORMAT;
    send_data(&mode, 1);

    send_cmd(ST7789_CMD_MADCTL); // 设置内存访问方向
    uint8_t madctl = ST7789_MADCTL_RGB_V;
    send_data(&madctl, 1);

    send_cmd(ST7789_CMD_DISPLAY_ON); // 开启显示
    ESP_LOGI(TAG, "显示屏初始化完成");
}

// 硬件复位
static void hardware_reset(void) {
    // 将ST7789_RES_PIN引脚电平设置为0，即低电平
    gpio_set_level(ST7789_RES_PIN, 0);
    // 延时20毫秒
    vTaskDelay(pdMS_TO_TICKS(20));
    // 将ST7789_RES_PIN引脚电平设置为1，即高电平
    gpio_set_level(ST7789_RES_PIN, 1);
    // 延时120毫秒
    vTaskDelay(pdMS_TO_TICKS(120));
}

// 发送命令
static void send_cmd(uint8_t cmd) {
    gpio_set_level(ST7789_DC_PIN, 0);
    spi_transaction_t t = {
        .length = 8,
        .tx_buffer = &cmd
    };
    ESP_ERROR_CHECK(spi_device_polling_transmit(hspi, &t));
}

// 发送数据
static void send_data(const uint8_t *data, size_t len) {
    gpio_set_level(ST7789_DC_PIN, 1);
    spi_transaction_t t = {
        .length = len * 8,
        .tx_buffer = data
    };
    ESP_ERROR_CHECK(spi_device_polling_transmit(hspi, &t));
}

// 设置显示窗口
static void set_address_window(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
    uint8_t buf[4];
    
    // 设置列地址
    send_cmd(ST7789_CMD_CASET);
    buf[0] = x0 >> 8; buf[1] = x0 & 0xFF;
    buf[2] = x1 >> 8; buf[3] = x1 & 0xFF;
    send_data(buf, 4);

    // 设置行地址
    send_cmd(ST7789_CMD_RASET);
    buf[0] = y0 >> 8; buf[1] = y0 & 0xFF;
    buf[2] = y1 >> 8; buf[3] = y1 & 0xFF;
    send_data(buf, 4);
}

// 清屏
void st7789_fill_screen(uint16_t color) {
    uint8_t color_byte[2];

    // 需要对RGB565数据取反才能显示正确的颜色(原因不明)
    // color_byte[0] = ~(color >> 8);
    // color_byte[1] = ~(color & 0xFF);
    // 使用硬件颜色反转（ST7789_CMD_INVON），无需软件取反
    color_byte[0] = (color >> 8);      // 高字节
    color_byte[1] = (color & 0xFF);    // 低字节

    set_address_window(0, 0, ST7789_WIDTH-1, ST7789_HEIGHT-1);

    // 准备单行缓冲区
    uint8_t line_buffer[ST7789_WIDTH * 2];
    for(int i=0; i<sizeof(line_buffer); i+=2) {
        line_buffer[i] = color_byte[0];
        line_buffer[i+1] = color_byte[1];
    }

    send_cmd(ST7789_CMD_RAMWR);
    // 逐行填充
    for(int y=0; y<ST7789_HEIGHT; y++) {
        send_data(line_buffer, sizeof(line_buffer));
    }
}

// 绘制图像
void st7789_draw_image(const uint16_t *image_data) {
    set_address_window(0, 0, ST7789_WIDTH-1, ST7789_HEIGHT-1);

    const uint8_t *data_ptr = (const uint8_t *)image_data;
    size_t remain = ST7789_WIDTH * ST7789_HEIGHT * 2;
    
    send_cmd(ST7789_CMD_RAMWR);
    while(remain > 0) { //  循环发送数据，每次发送不超过ST7789_MAX_TRANS_SIZE字节
        size_t send_size = (remain > ST7789_MAX_TRANS_SIZE) ? ST7789_MAX_TRANS_SIZE : remain;
        
        // 处理字节序转换（ESP32为Little-Endian，SPI发送需要Big-Endian）
        uint8_t buffer[send_size];
        for(int i=0; i<send_size/2; i++) {
            uint16_t color = ((uint16_t*)data_ptr)[i];
            buffer[i*2] = (color >> 8);      // 高字节
            buffer[i*2+1] = (color & 0xFF);  // 低字节
        }
        
        send_data(buffer, send_size);
        data_ptr += send_size;   // 指针偏移还未发送的字节数
        remain -= send_size;     // 记录还剩余的字节数
    }
}

void st7789_display_raw(const uint8_t *data, size_t len) {
    if(len != ST7789_WIDTH * ST7789_HEIGHT * 2) {
        ESP_LOGE(TAG, "数据长度不符号,当前数据长度为%d",len);
        return;
    }
    st7789_draw_image((const uint16_t *)data);
}